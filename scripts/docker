#!/bin/sh

## docker helper functions

# remove dangling images and exited containers
docker_cleanup()
{
    docker rm $(docker ps --filter status=exited -q 2>/dev/null) 2>/dev/null
    docker rmi $(docker images --filter dangling=true -q 2>/dev/null) 2>/dev/null
}

# delete old container with same name
docker_del_stopped_named()
{
    local name=$1
    local state=$(docker inspect --format "{{.State.Running}}" $name 2>/dev/null)

    if [[ "$state" == "false" ]]; then
        docker rm $name 1>/dev/null
    fi
}

# stop a running container with same name
docker_stop_named()
{
    local name=$1
    local state=$(docker inspect --format "{{.State.Running}}" $name 2>/dev/null)

    if [[ "$state" == "true" ]]; then
        docker stop $name 1>/dev/null
    fi
}

# restart daemon for overlay networking
docker_daemon_restart()
{
    sudo service docker stop >/dev/null 2&>1
    while [ -f /var/run/docker.pid ]; do
        sudo kill $(cat /var/run/docker.pid) >/dev/null 2&>1
        sleep 1
    done

    if [ -n "$1" ]; then
        if [ -n "$2" ]; then
            local nic=$2
        else
            local nic="eth1"
        fi
        sudo docker daemon --userns-remap="$USERNAME" --cluster-store=consul://$1:8500 --cluster-advertise=$nic:2376 >/dev/null 2&>1 & disown
    else
        sudo docker daemon --userns-remap="$USERNAME" >/dev/null 2&>1 & disown
    fi
}

# starts linked containers
docker_relies_on()
{
    local containers=$@

    for container in $containers; do
        local state=$(docker inspect --format "{{.State.Running}}" $container 2>/dev/null)

        if [[ "$state" == "false" ]] || [[ "$state" == "" ]]; then
            echo "$container is not running, starting it for you"
            $container
        fi
    done
}

# print the full command before running the container
docker_run()
{
    echo "docker run $@"
    docker run $@
}


## container aliases

# for common latex compilation
latexmk()
{
    docker_del_stopped_named latex                      `# delete old containers with same name`

    docker run --rm -it                                 `# remove container after use` \
        -v $(pwd):/latex                                `# share current directory as latex base directory` \
        --name latex                                    `# name the container, so we can delete later` \
        --net=none                                      `# no internet required inside the container` \
        harmish/latex latexmk --pdf -outdir=out $@      `# run latexmk inside latex container by setting default outdir`

    docker_stop_named latex                             `# stop the container, if-not already stopped`
}
lmk()
{
    latexmk $@
}

latex()
{
    docker_del_stopped_named latex                      `# delete old containers with same name`

    docker run --rm -it                                 `# remove container after use` \
        -v $(pwd):/latex                                `# share current directory as latex base directory` \
        --name latex                                    `# name the container, so we can delete later` \
        --net=none                                      `# no internet required inside the container` \
        harmish/latex $@                                `# run latex inside latex container`

    docker_stop_named latex                             `# stop the container, if-not already stopped`
}


# generic function for ros related containers
ros_docker()
{
    # check to see if at least image name was specified
    if [[ $# -lt 1 ]]; then
        echo "$(tput setaf 1)error: ros_docker called without image name";
        return 1;
    fi

    # parse the arguments with -c, -e, -M, -n, -o, -s, -v and --xvbf options
    declare -a args;
    declare -a envs;
    while [ $# -gt 0 ]; do
        case "$1" in
            # user networking of given container (name)
            --netc)
                shift;
                if [ -n "$1" ]; then
                    envs+=("--net=container:$1");
                    shift;
                fi
                ;;
            # add given environment variables to the container
            -e|--env)
                shift;
                if [ -n "$1" ]; then
                    envs+=("-e");
                    envs+=($1);
                    shift;
                fi
                ;;
            # set ROS_MASTER_URI to given IP or HOSTNAME
            --master)
                shift;
                if [ -n "$1" ]; then
                    envs+=("-e");
                    envs+=("ROS_MASTER_URI=http://$1:11311");
                    shift;
                fi
                ;;
            # name the container and ROS_HOSTNAME
            --name)
                shift;
                if [ -n "$1" ]; then
                    envs+=("--name=$1");
                    envs+=("-e");
                    envs+=("ROS_HOSTNAME=$1");
                    shift;
                fi
                ;;
            # specity network for the container
            --net)
                shift;
                if [ -n "$1" ]; then
                    envs+=("--net=$1");
                    shift;
                fi
                ;;
            # overlay given workspace
            -o|--overlay-rosws)
                shift;
                if [ -n "$1" ]; then
                    local overlay="$1/setup.bash";
                    shift;
                fi
                ;;
            # share screen for gui apps
            -s|--screen)
                shift;
                envs+=("-e");
                envs+=("DISPLAY=:0");
                envs+=("-v");
                envs+=("/tmp/.X11-unix:/tmp/.X11-unix:ro");
                envs+=("-e");
                envs+=("QT_GRAPHICSSYSTEM=native");
                ;;
            # add more volumes to the container
            -v|--volume)
                shift;
                if [ -n "$1" ]; then
                    envs+=("-v");
                    envs+=("$1");
                    shift;
                fi
                ;;
            # use virtual screen for the container, that has gui elements
            --xvbf)
                shift;
                envs+=("-e");
                envs+=("DISPLAY=:1");
                local xvbf=true;
                ;;
            # collect remaining arguments
            *)
                args+=($1);
                shift;
                ;;
        esac
    done

    # set remaining arguments as container process arguments
    set -- $args;

    # get image for the container
    local img=$1;
    shift;

    # set entryponit and master-uri when asked
    declare -a ent;
    declare -a copt;
    if [ -n "${overlay+1}" ]; then
        ent=("--entrypoint" "bash");
        if [ "$xvbf" = true ] ; then
            copt+=("-c");
            copt+=("\"source $overlay; Xvfb -screen 0 1024x768x24 :1 >/dev/null 2>&1 & $*\"");
        else
            copt+=("-c");
            copt+=("source $overlay; $*");
        fi
    else
        copt=($@);
    fi

    # set working directory to current directory if found under $HOME/ros
    if [ "${$(pwd)##$HOME/ros}" != "$(pwd)" ]; then
        local ros_workdir="$(pwd)";
    else
        local ros_workdir="/";
    fi

    mkdir -p $HOME/.ros                                     `# create ros settings directory if-not-exist`
    mkdir -p $HOME/.config/catkin                           `# create catkin config directory if-not-exist`
    mkdir -p $HOME/.rviz                                    `# create rviz config directory if-not-exist`

    docker_run --rm -it                                     `# remove container after use` \
        -v $HOME/.ros:/root/.ros                            `# sahre ros settings directory, required by catking build` \
        -v $HOME/.config/catkin:/root/.config/catkin        `# share catkin config directory, required by catking build` \
        -v $HOME/.rviz:/root/.rviz                          `# share rviz config directory` \
        -v $HOME/ros:$HOME/ros                              `# sharing all ros workspaces, with same path under host` \
        $envs                                               `# setting additional evnironment variables` \
        -e SHELL=/bin/bash                                  `# setting deafult shell, needed by catkin` \
        -w $ros_workdir                                     `# setting ros working directory` \
        $ent                                                `# setting the entrypoint` \
        harmish/$img $copt                                  `# passing remaining arguments`
}

indigo-base(){
    ros_docker ros:indigo-base $@           `# run ros_docker with indigo-base image`
}

indigo-robot(){
    ros_docker ros:indigo-robot $@          `# run ros_docker with indigo-robot image`
}

indigo-navigation(){
    ros_docker ros:indigo-navigation $@     `# run ros_docker with indigo-navigation image`
}

indigo-desktop-full(){
    ros_docker ros:indigo-desktop-full $@   `# run ros_docker with indigo-desktop-full image`
}

indigo-ultimate(){
    ros_docker ros:indigo-ultimate $@       `# run ros_docker with indigo-ultimate image`
}

jade-base(){
    ros_docker ros:jade-base $@             `# run ros_docker with jade-base image`
}

jade-robot(){
    ros_docker ros:jade-robot $@            `# run ros_docker with jade-robot image`
}

jade-navigation(){
    ros_docker ros:jade-navigation $@       `# run ros_docker with jade-navigation image`
}

jade-desktop-full(){
    ros_docker ros:jade-desktop-full $@     `# run ros_docker with jade-desktop-full image`
}

jade-ultimate(){
    ros_docker ros:jade-ultimate $@         `# run ros_docker with jade-ultimate image`
}

catkin_create_pkg(){
    jade-desktop-full                                                                                                           `# call jade-desktop-full which call ros_docker` \
        --overlay-rosws $HOME/ros/catkin_ws/install                                                                             `# overlay on catkin_ws` \
        "cd $HOME/ros/infrastructure/catkin_pkg && python setup.py install > /dev/null 2>&1 && cd - && catkin_create_pkg $@"    `# install catkin_pkg and run catkin_create_pkg from this installed version`
}

optitrack(){
    ros_docker robotpkg:optitrack $@        `# run ros_docker with robotpkg-optitrack image`
}

spencer(){
    ros_docker spencer:indigo $@            `# run ros_docker with spencer-indigo image`
}

# jade-web-devel(){
#     ros_docker ros:jade-web-devel $@        `# run ros_docker with jade-web-devel image`
# }

# ros-web(){
#     docker run --rm -it \
#         --net=host \
#         -v $HOME/ros/web:/root/ros/web \
#         harmish/ros:web-devel $@
# }

# ros-web-devel(){
#     docker run --rm -it \
#     -v $(pwd):${$(pwd)/$HOME//root} \
#     -w ${$(pwd)/$HOME//root} \
#     harmish/ros:web-devel $@
# }

morse(){
    docker run --rm -it                     `# remove container after use` \
        harmish/morse:morse $@              `# run morse with given arguments`
}

morse-ros(){
    ros_docker --xvbf morse:ros-pr2 $@
}

julia(){
    local JULIA_DIR=$HOME
    touch $JULIA_DIR/.julia_history                         `# create julia_history file if-not-exist`
    mkdir -p $JULIA_DIR/.julia                              `# create julia package directory if-not-exist`

    docker run --rm -it                                     `# remove container after use` \
        -v $JULIA_DIR/.julia_history:/root/.julia_history   `# share julia_history` \
        -v $JULIA_DIR/.julia:/root/.julia                   `# share julia packages` \
        -v $(pwd):$(pwd)                                    `# mount current directory` \
        -w $(pwd)                                           `# start workspaces at current directory` \
        harmish/julia:latest julia $@                       `# execute julia with given arguments`
}

node(){
    docker run --rm -it             `# remove container after use` \
        -v $(pwd):$(pwd)            `# mount currnet directory` \
        -w $(pwd)                   `# start workspaces at current directory` \
        node node $@                `# execute node with given arguments`
}

npm(){
    mkdir -p $HOME/.npm             `# create npm package directory if-not-exist`

    docker run --rm -it             `# remove container after use` \
        -v $HOME/.npm:/.npm         `# share npm package directory` \
        -v $(pwd):$(pwd)            `# mount currnet directory` \
        -w $(pwd)                   `# start workspaces at current directory` \
        node npm $@                 `# execute npm from node-image with given arguments`
}

jekyll(){
    docker_del_stopped_named jekyll `# delete old containers with same name`

    docker run --rm -t              `# remove container after use` \
        -p 4000:4000                `# share default jekyll port` \
        --name jekyll               `# name the container` \
        -v $(pwd):$(pwd)            `# mount current directory` \
        -w $(pwd)                   `# start workspaces at current directory` \
        harmish/jekyll jekyll $@    `# execute jekyll with given arguments`

    docker_stop_named jekyll        `# stop the container`
}

rstudio(){
    mkdir -p $HOME/.rstudio                 `# create julia package directory if-not-exist`

    docker run --rm -t                      `# remove container after use` \
        --name rstudio                      `# name the container` \
        -p 8787:8787                        `# share default port of rserver` \
        -v $HOME/.rstudio:/root/.rstudio    `# share user-rstudio directory` \
        -v $(pwd):/root                     `# share current directory as working directory` \
        harmish/rstudio:latest              `# run rstudio-server`

    docker_stop_named rstudio
}
